package poopgame.gamelogic;

import java.util.ArrayList;
import java.util.List;

import com.badlogic.ashley.core.Entity;
import com.badlogic.ashley.core.Family;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;

import poopgame.gamelogic.engine.TimeEngine;
import poopgame.graphics.components.TransformComponent;
import poopgame.physics.BodyInfo;
import poopgame.physics.components.BodyComponent;
import poopgame.util.InternalAssetLoader;

public class Bird extends GameEntity {

	private static final float SPEED = 2.5f;
	private static final float POOP_COOLDOWN = 0.75f;
	private static final float DURATION = 10f;
	
	private static final String CREATION_TIME = "creationTime";
	private static final String RISING = "rising";
	private static final String LAST_POOP = "lastPoop";

	public Entity owner;

	public Bird(Entity owner) {
		super(0.5f, 0.5f, true);
		this.owner = owner;
	}
	
	@Override
	public String generateId() {
		return generateChildId(owner, "Bird");
	}
	
	@Override
	public Entity create(TimeEngine engine, Vector2 position) {
		Entity entity = super.create(engine, position);
		entity.getComponent(TransformComponent.class).mustBeInFrame = true;
		getStats(entity).setOwnerId(getId(owner));
		getStats(entity).setStat(CREATION_TIME, engine.getTime());
		return entity;
	}

	private static Entity findTarget(TimeEngine engine, Entity bird, Entity owner) {
		List<Body> targets = new ArrayList<>();
		for (Entity entity : engine.getEntitiesFor(Family.all(BodyComponent.class).get())) {
			BodyComponent bodyComp = entity.getComponent(BodyComponent.class);
			BodyInfo bodyInfo = (BodyInfo) bodyComp.body.getUserData();
			if (bodyInfo.origin instanceof Player && bodyInfo.origin != owner)
				targets.add(bodyComp.body);
		}

		Body birdBody = getBody(bird);
		Body closest = null;
		float closestDist = 0;
		for (Body target : targets) {
			float dist = Math.abs(birdBody.getPosition().y - target.getPosition().y);
			if (closest == null || dist < closestDist) {
				closest = target;
				closestDist = dist;
			}
		}

		target = closest;
	}

	@Override
	public static void update(TimeEngine engine, Entity entity, float delta) {
		long current = System.currentTimeMillis();

		// check if expired
		if (creationTime != null && current - creationTime > duration) {
			creationTime = null;
			game.executeAfterNextUpdate(new Runnable() {

				@Override
				public void run() {
					game.engine.removeEntity(entity);
					game.world.destroyBody(body);
					entity = null;
					body = null;
				}
			});
		}

		// movement
		float maxY = getFlightHeight();
		if (maxY - body.getPosition().y > 0.01f) {
			rising = true;
			body.setTransform(body.getPosition().x, body.getPosition().y + speed * 3 * delta, 0);
		} else {
			rising = false;
			if (target != null) {
				float travelDist = 0;
				float xDist = target.getPosition().x - body.getPosition().x;
				if (xDist > 0) {
					travelDist = speed * delta;
					if (travelDist > xDist)
						travelDist = xDist;
				} else if (xDist < 0) {
					travelDist = -speed * delta;
					if (travelDist < xDist)
						travelDist = xDist;
				}
				body.setTransform(body.getPosition().x + travelDist, body.getPosition().y, 0);
			}
		}

		// pooping
		if (!rising && current - lastPoop > poopCooldown) {
			BirdPoop poop = new BirdPoop();
			poop.create(game, false, InternalAssetLoader.getSound(Champion.TRUMP.getFolderName() + "special/birdpoop.mp3"));
			lastPoop = current;
		}
	}

	private float getFlightHeight() {
		return game.tiledMapCollision.getMapDimensions().y - height * 2;
	}

	@Override
	protected String getTextureName() {
		return Champion.TRUMP.getFolderName() + "special/bird.png";
	}

	@Override
	protected Vector2 getSpawnPosition() {
		Vector2 pos = owner.body.getTransform().getPosition().cpy();
		float maxY = getFlightHeight();
		if (pos.y > maxY)
			pos.y = maxY;
		return pos;
	}

	@Override
	protected BodyDef getBodyDef() {
		BodyDef bodyDef = super.getBodyDef();
		bodyDef.type = BodyType.KinematicBody;
		return bodyDef;
	}

	private class BirdPoop extends Poop {

		public BirdPoop() {
			super(owner);
			width = 0.1f;
			height = 0.3f;
			damageAmpPerSec = 0;
		}

		@Override
		public String getTextureName() {
			return Champion.TRUMP.getFolderName() + "special/birdpoop.png";
		}

		@Override
		protected Vector2 getSpawnPosition() {
			return Bird.this.body.getPosition();
		}

	}
}
