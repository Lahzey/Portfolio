package poopgame.gamelogic;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;

import poopgame.gamelogic.abilities.passive.PassiveAbility;
import poopgame.gamelogic.abilities.special.SpecialAbility;
import poopgame.gamelogic.components.PlayerComponent;
import poopgame.gamelogic.engine.TimeEngine;
import poopgame.gamelogic.engine.actions.Action;
import poopgame.graphics.components.AnimationComponent;
import poopgame.graphics.components.TransformComponent;
import poopgame.util.GifDecoder;
import util.ArrayUtil;
import util.ExtendedThread;
import util.GenericListener;

public class Player extends GameEntity {
	
	private static final long MAX_CHARGE_TIME = 5000;
	private static final float MAX_CHARGE_DMG_AMP = 3f;
	private static final float MAX_CHARGE_SPEED_AMP = 5f;
	
	private static final Random RANDOM = new Random();

	private PlayerComponent playerComponent = new PlayerComponent();
	private final InputMap inputMap;
	
	private Vector2 spawnPosition = new Vector2(); // will be overwritten when initialising map
	
	private AnimationComponent animationComponent;
	private Animation<TextureRegion> walkLeft;
	private Animation<TextureRegion> walkRight;
	private Animation<TextureRegion> standLeft;
	private Animation<TextureRegion> standRight;
	
	private List<GenericListener<Poop>> shootListeners = new ArrayList<>(); 
	
	public Player(Long id, String name, Champion champ) {
		this(id, name, champ, new InputMap());
	}
	
	public Player(String name, Champion champ, InputMap inputMap) {
		this(RANDOM.nextLong(), name, champ, inputMap);
	}
	
	public Player(Long id, String name, Champion champ, InputMap inputMap) {
		super(0.5f, 1f, false);
		this.inputMap = inputMap;

		playerComponent.id = id;
		playerComponent.name = name;
		playerComponent.champ = champ;
		playerComponent.stats = new Stats();
		playerComponent.special = champ.createSpecialAbility(this);
		playerComponent.passive = champ.createPassiveAbility(this);
	}
	
	public long getPlayerId() {
		return playerComponent.id;
	}
	
	public String getName() {
		return playerComponent.name;
	}
	
	public void setName(String name) {
		playerComponent.name = name;
	}
	
	public Champion getChampion() {
		return playerComponent.champ;
	}
	
	public void setChampion(Champion champ) {
		playerComponent.champ = champ;
	}
	
	public Stats getStats() {
		return playerComponent.stats;
	}
	
	public SpecialAbility getSpecial() {
		return playerComponent.special;
	}
	
	public PassiveAbility getPassive() {
		return playerComponent.passive;
	}
	
	public InputMap getInputMap() {
		return inputMap;
	}
	
	@Override
	public String generateId() {
		return "Player[" + getPlayerId() + "]";
	}
	
	public static String generateChildIdentifier(Entity entity, String childName) {
		int idIndex = getStats().getIdIndex();
		getStats().setIdIndex(idIndex + 1);
		return getId() + "/" + objectName + "[" + idIndex + "]";
	}
	
	public void addShootListener(GenericListener<Poop> listener) {
		shootListeners.add(listener);
	}
	
	@Override
	public void create(PoopGame game) {
		super.create(game);
		entity.add(playerComponent);
		entity.getComponent(TransformComponent.class).mustBeInFrame = true;

		walkLeft = GifDecoder.loadGIFAnimation(Animation.PlayMode.LOOP, Gdx.files.internal(getChampion().getFolderName() + "walk_left.gif").read());
		walkRight = GifDecoder.loadGIFAnimation(Animation.PlayMode.LOOP, Gdx.files.internal(getChampion().getFolderName() + "walk_right.gif").read());
		standLeft = GifDecoder.loadGIFAnimation(Animation.PlayMode.LOOP, Gdx.files.internal(getChampion().getFolderName() + "stand_left.gif").read());
		standRight = GifDecoder.loadGIFAnimation(Animation.PlayMode.LOOP, Gdx.files.internal(getChampion().getFolderName() + "stand_right.gif").read());
		animationComponent = new AnimationComponent();
		animationComponent.animation = standRight;
		entity.add(animationComponent);
	}

	private boolean isOnGround() {
		return Math.abs(body.getLinearVelocity().y) < 0.01 && fixInfo.colliding.size() > 0;
	}
	
	public void die() {
		destroy();
		new ExtendedThread() {
			
			@Override
			public void run() {
				System.out.println(playerComponent.name + " lost");
				sleepSilent(1000);
				System.exit(0);
			}
		}.start();
	}
	

	@Override
	public void update(float delta) {
		Stats stats = getStats();
		
		// check if dead
		if (stats.getHealth() <= 0) {
			die();
		}
		
		// set velocity
		float currentXVelocity = body.getLinearVelocity().x;
		float diff = getDesiredXVelocity() - currentXVelocity;
		if(Math.abs(diff) > 0.01) body.applyLinearImpulse(new Vector2(body.getMass() * diff, 0), body.getWorldCenter(), true);

		Vector2 position = body.getPosition();
		if(position.y < -height) die();
		
		// wrap around
		float maxX = game.tiledMapCollision.getMapDimensions().x;
		if(position.x < 0) body.setTransform(maxX, position.y, 0);
		else if(position.x > maxX) body.setTransform(0, position.y, 0);
		
		// regenerate energy
		stats.setEnergy(stats.getEnergy() + (stats.getEnergyRegen() * delta));
	}
	
	public void setSpawnPosition(Vector2 spawnPosition) {
		this.spawnPosition = spawnPosition;
	}

	@Override
	protected Vector2 getSpawnPosition() {
		return spawnPosition;
	}

	@Override
	protected String getTextureName() {
		return getChampion().getFolderName() + "model.png"; // will be overwritten by animation
	}
	
	private int getDesiredXVelocity() {
		int velocity = 0;
		if (getStats().isMovingRight()) velocity += playerComponent.stats.getSpeed();
		if (getStats().isMovingLeft()) velocity -= playerComponent.stats.getSpeed();
		return velocity;
	}

	public void executeAction(Action action, TimeEngine engine) {
		if (!alive) {
			return;
		}
		
		switch(action.getType()) {
		case JUMP:
			tryJump();
			break;
		case MOVE_LEFT_END:
			getStats().setMovingLeft(false);
			if (!getStats().isMovingRight()) {
				animationComponent.animation = standLeft;
			}
			break;
		case MOVE_LEFT_START:
			getStats().setMovingLeft(true);
			animationComponent.animation = walkLeft;
			break;
		case MOVE_RIGHT_END:
			getStats().setMovingRight(false);
			if (!getStats().isMovingRight()) {
				animationComponent.animation = standRight;
			}
			break;
		case MOVE_RIGHT_START:
			getStats().setMovingRight(true);
			animationComponent.animation = walkRight;
			break;
		case POOP_END:
			tryShoot(engine.getTime());
			break;
		case POOP_START:
			getStats().setShootStart(engine.getTime());
			break;
		case SPECIAL:
			trySpecial(engine);
			break;
		}
	}
	
	private void tryJump() {
		if(isOnGround()) {
			body.applyLinearImpulse(new Vector2(0, playerComponent.stats.getJumpForce() * body.getMass()), body.getPosition(), true);
			ArrayUtil.randomElementFrom(playerComponent.champ.getJumpSounds()).play();
		}
	}
	
	private void tryShoot(long currentTime) {
		long chargeTime = getStats().getShootStart() > 0 ? currentTime - getStats().getShootStart() : 0;
		getStats().setShootStart(0);
		
		if (getStats().getLastShot() + (1000 / playerComponent.stats.getPoopingSpeed()) > currentTime) {
			// cannot shoot yet
			return;
		}
		
		Poop poop;
		if (chargeTime < 500) {
			// normal shot
			poop = new Poop(this);
			poop.create(game);
		} else {
			// charged shot
			chargeTime = Math.min(chargeTime, 5000);
			float chargePercentage = chargeTime / (float) MAX_CHARGE_TIME;
			poop = new Poop(this);
			poop.damage *= ((MAX_CHARGE_DMG_AMP - 1) * chargePercentage) + 1;
			poop.damageAmpPerSec = 0;
			poop.create(game);

			Body poopBody = poop.getBody();
			float shootUpForce = playerComponent.stats.getShootUpForce() * poopBody.getMass();
			shootUpForce *= ((MAX_CHARGE_SPEED_AMP - 1) * chargePercentage) + 1;
			poopBody.applyLinearImpulse(new Vector2(0, shootUpForce), poopBody.getPosition(), true);
		}
		
		getStats().setLastShot(currentTime);
		
		for (GenericListener<Poop> listener : shootListeners) {
			listener.actionPerformed(poop);
		}
	}
	
	private void trySpecial(TimeEngine engine) {
		if (getStats().getEnergy() >= 100) {
			getStats().setEnergy(0);
			getSpecial().cast(engine);
		}
	}
}
