package poopgame.gamelogic;

import java.util.ArrayList;
import java.util.List;

import com.badlogic.ashley.core.Entity;
import com.badlogic.ashley.core.Family;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;

import poopgame.graphics.components.TransformComponent;
import poopgame.physics.BodyInfo;
import poopgame.physics.components.BodyComponent;
import poopgame.util.InternalAssetLoader;

public class Bird extends GameEntity {

	public Player owner;

	public float speed = 2.5f;
	public float poopCooldown = 750;

	private Body target;

	private boolean rising = true;
	private long lastPoop = 0;

	private Long creationTime;
	private long duration = 10000;

	public Bird(Player owner) {
		super(0.5f, 0.5f, true);
		this.owner = owner;
	}

	public void create(PoopGame game) {
		super.create(game);
		entity.getComponent(TransformComponent.class).mustBeInFrame = true;
		findTarget();
		creationTime = System.currentTimeMillis();
	}

	private void findTarget() {
		List<Body> targets = new ArrayList<>();
		for (Entity entity : game.engine.getEntitiesFor(Family.all(BodyComponent.class).get())) {
			BodyComponent bodyComp = entity.getComponent(BodyComponent.class);
			BodyInfo bodyInfo = (BodyInfo) bodyComp.body.getUserData();
			if (bodyInfo.origin instanceof Player && bodyInfo.origin != owner)
				targets.add(bodyComp.body);
		}

		Body closest = null;
		float closestDist = 0;
		for (Body target : targets) {
			float dist = Math.abs(body.getPosition().y - target.getPosition().y);
			if (closest == null || dist < closestDist) {
				closest = target;
				closestDist = dist;
			}
		}

		target = closest;
	}

	@Override
	public void update(float delta) {
		long current = System.currentTimeMillis();

		// check if expired
		if (creationTime != null && current - creationTime > duration) {
			creationTime = null;
			game.executeAfterNextUpdate(new Runnable() {

				@Override
				public void run() {
					game.engine.removeEntity(entity);
					game.world.destroyBody(body);
					entity = null;
					body = null;
				}
			});
		}

		// movement
		float maxY = getFlightHeight();
		if (maxY - body.getPosition().y > 0.01f) {
			rising = true;
			body.setTransform(body.getPosition().x, body.getPosition().y + speed * 3 * delta, 0);
		} else {
			rising = false;
			if (target != null) {
				float travelDist = 0;
				float xDist = target.getPosition().x - body.getPosition().x;
				if (xDist > 0) {
					travelDist = speed * delta;
					if (travelDist > xDist)
						travelDist = xDist;
				} else if (xDist < 0) {
					travelDist = -speed * delta;
					if (travelDist < xDist)
						travelDist = xDist;
				}
				body.setTransform(body.getPosition().x + travelDist, body.getPosition().y, 0);
			}
		}

		// pooping
		if (!rising && current - lastPoop > poopCooldown) {
			BirdPoop poop = new BirdPoop();
			poop.create(game, false, InternalAssetLoader.getSound(Champion.TRUMP.getFolderName() + "special/birdpoop.mp3"));
			lastPoop = current;
		}
	}

	private float getFlightHeight() {
		return game.tiledMapCollision.getMapDimensions().y - height * 2;
	}

	@Override
	protected String getTextureName() {
		return Champion.TRUMP.getFolderName() + "special/bird.png";
	}

	@Override
	protected Vector2 getSpawnPosition() {
		Vector2 pos = owner.body.getTransform().getPosition().cpy();
		float maxY = getFlightHeight();
		if (pos.y > maxY)
			pos.y = maxY;
		return pos;
	}

	@Override
	protected BodyDef getBodyDef() {
		BodyDef bodyDef = super.getBodyDef();
		bodyDef.type = BodyType.KinematicBody;
		return bodyDef;
	}

	private class BirdPoop extends Poop {

		public BirdPoop() {
			super(owner);
			width = 0.1f;
			height = 0.3f;
		}

		@Override
		public String getTextureName() {
			return Champion.TRUMP.getFolderName() + "special/birdpoop.png";
		}

		@Override
		protected Vector2 getSpawnPosition() {
			return Bird.this.body.getPosition();
		}

	}
}
