package poopgame.gamelogic;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.badlogic.gdx.physics.box2d.Fixture;
import com.badlogic.gdx.physics.box2d.Shape;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;

import poopgame.physics.BodyInfo;

public class AtomicPoop extends Poop {

	private Runnable detonationCallback;

	public AtomicPoop(Player pooper, Runnable detonationCallback) {
		super(pooper);
		this.detonationCallback = detonationCallback;
		damageAmpPerSec = 0;
		damage = 1000000;
	}

	@Override
	public String getTextureName() {
		return Champion.KIM.getFolderName() + "special/atomicpoop.png";
	}

	protected boolean isCollidingTargetValid(Fixture colliding) {
		return true;
	}

	public void detonate() {
		destroy();
		createAtomicWaste();
	}

	public void createAtomicWaste() {
		destroy();
		new AtomicWaste().create(game);
		detonationCallback.run();
	}

	@Override
	public void update(float delta) {
		super.update(delta);
		if (!alive) {
			detonationCallback.run();
		}
	}

	@Override
	protected void onConfirmedCollision(Player player) {
		super.onConfirmedCollision(player);
		detonate();
	}

	private class AtomicWaste extends GameEntity {

		private static final float MIN_DIAMETER = 0.5f;
		private static final float MAX_DIAMETER = 5f;
		private static final int DAMAGE_PER_SEC = 50;

		private long duration = 7000;
		private long expandDuration = 1000;
		private long spawnedAt;

		public AtomicWaste() {
			super(MIN_DIAMETER, MIN_DIAMETER, true);
		}

		public void create(PoopGame game) {
			super.create(game);
			spawnedAt = System.currentTimeMillis();
		}

		@Override
		public void update(float delta) {
			long current = System.currentTimeMillis();
			for (Fixture colliding : fixInfo.colliding.values()) {
				BodyInfo collidingInfo = (BodyInfo) colliding.getBody().getUserData();
				if (collidingInfo.origin instanceof Player) {
					Player victim = (Player) collidingInfo.origin;
					victim.getStats().setHealth(victim.getStats().getHealth() - (DAMAGE_PER_SEC * delta));
				}
			}

			if (current - spawnedAt > duration) {
				destroy();
			}

			CircleShape shape = (CircleShape) fixInfo.fixture.getShape();
			double progress = Math.min(1, ((double) current - spawnedAt) / expandDuration);
			float diameter = (float) (MIN_DIAMETER + (MAX_DIAMETER - MIN_DIAMETER) * progress);
			shape.setRadius(diameter / 2);
			fixInfo.width = diameter;
			fixInfo.height = diameter;
			body.setTransform(body.getPosition().add(0, 10 * delta / (duration / 1000)), 0);
		}

		@Override
		protected Shape getShape() {
			CircleShape shape = new CircleShape();
			shape.setRadius(MIN_DIAMETER / 2);
			return shape;
		}

		@Override
		protected String getTextureName() {
			return Champion.KIM.getFolderName() + "special/atomicwaste.png";
		}

		@Override
		protected Vector2 getSpawnPosition() {
			return AtomicPoop.this.body.getPosition();
		}

		@Override
		protected BodyDef getBodyDef() {
			BodyDef bodyDef = super.getBodyDef();
			bodyDef.type = BodyType.StaticBody;
			return bodyDef;
		}
	}

}
