package poopgame.graphics.systems;

import java.util.ArrayList;
import java.util.List;

import com.badlogic.ashley.core.ComponentMapper;
import com.badlogic.ashley.core.Entity;
import com.badlogic.ashley.core.Family;
import com.badlogic.ashley.systems.IteratingSystem;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector3;

import poopgame.graphics.components.TransformComponent;

public class CameraSystem extends IteratingSystem {
	
	private static final float PADDING = 2f;
	private static final float MAX_CHANGE_SPEED = 10; // in meters per second
	
	private final RenderingSystem renderingSystem;
	private final Rectangle bounds = new Rectangle();
	
    private final ComponentMapper<TransformComponent> transformMapper;
    
    private final List<Vector3> mustRenderPositions = new ArrayList<>();
    
    public CameraSystem(RenderingSystem renderingSystem) {
        super(Family.all(TransformComponent.class).get());
        this.renderingSystem = renderingSystem;
        
        transformMapper = ComponentMapper.getFor(TransformComponent.class);
    }

    @Override
    public void update(float deltaTime) {
    	mustRenderPositions.clear();
    	super.update(deltaTime);

    	float minX = Float.MAX_VALUE;
    	float minY = Float.MAX_VALUE;
    	float maxX = Float.MIN_VALUE;
    	float maxY = Float.MIN_VALUE;
    	
    	if(!mustRenderPositions.isEmpty()){
        	// get smallest and biggest coordinate of all players
        	for(Vector3 position : mustRenderPositions){
        		if(position.x < minX) minX = position.x;
        		if(position.y < minY) minY = position.y;
        		if(position.x > maxX) maxX = position.x;
        		if(position.y > maxY) maxY = position.y;
        	}
        	
        	// add padding
        	minX -= PADDING;
        	minY -= PADDING;
        	maxX += PADDING;
        	maxY += PADDING;
        	
        	float maxBoundsX = bounds.x + bounds.width;
        	float maxBoundsY = bounds.y + bounds.height;
        	minX = Math.max(bounds.x, Math.min(maxBoundsX, minX));
        	minY = Math.max(bounds.y, Math.min(maxBoundsY, minY));
        	maxX = Math.max(bounds.x, Math.min(maxBoundsX, maxX));
        	maxY = Math.max(bounds.y, Math.min(maxBoundsY, maxY));
    	} else {
    		minX = bounds.x;
    		minY = bounds.y;
    		maxX = minX + bounds.width;
    		maxY = minY + bounds.height;
    	}
    	
    	// smooth transition
    	float maxTransition = MAX_CHANGE_SPEED * deltaTime;
    	float maxTransitionNegative = maxTransition * -1;
    	
    	float currentMinX = renderingSystem.mustRender.x;
    	float currentMinY = renderingSystem.mustRender.y;
    	float currentMaxX = currentMinX + renderingSystem.mustRender.width;
    	float currentMaxY = currentMinY + renderingSystem.mustRender.height;
    	float minXDif = minX - currentMinX;
    	float minYDif = minY - currentMinY;
    	float maxXDif = maxX - currentMaxX;
    	float maxYDif = maxY - currentMaxY;
    	
    	if (minXDif < 0) {
    		if (minXDif < maxTransitionNegative) minXDif = maxTransitionNegative;
    	} else {
    		if (minXDif > maxTransition) minXDif = maxTransition;
    	}

    	if (minYDif < 0) {
    		if (minYDif < maxTransitionNegative) minYDif = maxTransitionNegative;
    	} else {
    		if (minYDif > maxTransition) minYDif = maxTransition;
    	}

    	if (maxXDif < 0) {
    		if (maxXDif < maxTransitionNegative) maxXDif = maxTransitionNegative;
    	} else {
    		if (maxXDif > maxTransition) maxXDif = maxTransition;
    	}

    	if (maxYDif < 0) {
    		if (maxYDif < maxTransitionNegative) maxYDif = maxTransitionNegative;
    	} else {
    		if (maxYDif > maxTransition) maxYDif = maxTransition;
    	}

    	System.out.println(currentMinX + "/" + currentMinY + " | " + currentMaxX + "/" + currentMaxY);
    	
    	System.out.println(minXDif + "/" + minYDif + " | " + maxXDif + "/" + maxYDif);
    	
    	renderingSystem.mustRender.x += minXDif;
    	renderingSystem.mustRender.y += minYDif;
    	renderingSystem.mustRender.width = (currentMaxX + maxXDif) - minXDif;
    	renderingSystem.mustRender.height = (currentMaxY + maxYDif) - minYDif;
    	
    	System.out.println(renderingSystem.mustRender);
    	
    	System.out.println();
    }

    @Override
    public void processEntity(Entity entity, float deltaTime) {
        TransformComponent transformComp = transformMapper.get(entity);
        if (transformComp.mustBeInFrame) {
            mustRenderPositions.add(transformComp.position);
        }
    }

    public void setBounds(Rectangle bounds){
    	this.bounds.set(bounds);
    }
    
}
